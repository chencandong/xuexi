## 如何获取一条命令的执行条件

$?为返回上一条命令的执行状态，当返回为0时表示的是命令正常执行，当返回的是1的时候表示的命令不正常执行

$0表示的是当前脚本的文件名

$n表示的是传递给脚本或者函数的参数，n是一个数字，表示第几个参数

$#表示的是传递给脚本或者函数的所有参数个数

$*传递给脚本或者函数的所有参数

$@都表示传递给函数或脚本的所有参数，不被双引号包括时，都以$1,$2,$3,$4的形式输出，当被双引号包含时，$*会将所有的参数以'$1$2$3$4’的形式输出，但是$@会将各个参数分隔开来，以$1,$2,$3,$4的形式输出


$?上个命令的退出状态或者函数的返回值

$$当前shell进程id，对于shell脚本就是这些脚本所在的进程id

## 如何使用命令行中的位置参数
命令行参数是位置参数，可以在脚本中使用，例如$1表示的是第一个参数，$2表示的第二个参数，$3表示的是第三个参数，$#可以获取参数的个数，使用$@和$*可以获取所有的参数与，使用set命令可以设置或者重置位置参数，也可以删除之前设置的所有位置参数

## 如何解析命令行中的选项
1. 直接处理，使用$1,$2,$3搭配shift来进行解析，进行手工处理

2. 使用getopts来处理，处理负载选项时候建议使用，但是在跨平台兼容性方面会存在一些问题

##正则表达式跟shell通配符的区别在于哪里，哪些命令使用正则表达式，哪些使用shell通配符
通配符是系统级别的，而正则表达式需要相关工具的支持，例如egrep,awk,perl，在文本中都是使用正则表达式，比如awk，sed是针对文件的内容得问，通配符多半用于文件名中，比如查找find，ls，cp

shell的通配符：（*当我们在shell中药使用字符本身的意义而不是其通配符的时，可以使用转义字符'/'*）

*：代表任意个字符，包括空字符

？：代表单个字符

[abc]代表啊a,b,c中的一个字符

[!abc]除了a,b,c之外的任意字符

[a-z]a到z之间的任意一个asscii字符

[!a-x]除了a到z之外任意的一个asscii字符

{part1，part2}模式1，模式2


正则表达式：

+：匹配一个或者多个前面的字符，与*的区别在于它不能匹配空串

？：可以匹配0个或者一个它前面的字符，与.的区别在于它可以匹配0个前面的字符

exp1|exp2匹配exp1和exp2

（x1|x2）x3匹配x1x3或者x2x3

^匹配行首

$匹配行尾

[]匹配中括号中的指定的一个字符，只匹配一个字符

[^]匹配中括号中指定的任意一个字符

\{n,\} 表示其前面的字符不小于n次

\{n,m} 表示其前面的字符至少出现n次，最多出现m次


##对比move和copytruncate两种模式的优缺点及使用场景 




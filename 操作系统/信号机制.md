## 请简述kill命令的原理 

kill命令向系统内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对系统标识号指定的进程进行操作了。执行kill命令需要一个pid，根据这个pid可以找个这个进程的task_struct，然后在这个结构体的特定的成员变量里记下这个信号，这时候信号产生了但是还没有被处理，等到下一次cpu调度到这个进程的时候会看看有没有需要被处理的信号，若有就处理没有就直接执行这个程序。通常终止一个前端进程可以使用ctrl+C键，但是对于后台进程就必须要使用kill命令来终止

常见的系统操作信号有：

* 1HUP终端断线
* 2INT终端
* 3QUIT退出
* 15TERM终止
* 9Kill强制终止
* 18CONT继续
* 19STOP停止

可以使用kill -l来获取所需要的信号列表

## 请简述nohup命令工作的原理
当启动nohup的时候首先去判断当前标准输入，输出以及错误输出的文件描述符是否在一个终端中，如果在终端中运行的话，修改标准输入，打开/dev/null作为进程的标准输入，打开nohup.out文件，优先在当前目录创建，如果创建失败就在用户的家目录创建nohup.out的文件，将标准输出也定向到nohup.out的目录中。让后向系统注册一个sighup信号，处理的方式为忽略，系统默认的方式kill进程，然后execvp函数执行后面的进程，nohup的作用就是让程序忽视sighup信号，避免终端连接终端时候，进程被kull，同事改变标准进程的输入输出。当一个会话终端后，系统只会给当前会话的前台进程组发送sighup信号，如果启动进程，让进程在后台去执行，会话中断的时候是不会收到sighup信号的，也不会被系统kill。nohup本身是不会将程序放入后台执行的

## 如何在bash脚本中处理用户的ctrl+c的请求？

脚本如下可参考：

 #!/bin/bash

trap 'onctrlC' INT

function onctrlC(){

	echo "you print ctrl +c "

}

while true;do 

	echo "print ctrl+c please"
	sleep 1
done


常见的一些信号：

1. SIGHUP 
2. SIGINT:程序终止信号，在用户输入INTR（*通常为ctrl+C*）时候发出，通知前台终止进程
3. SiGQUIT:与2类似但是一般由于ctrl+\来控制，退出的时候会产生core文件，这个意义上类似一个程序错误信号
4. SIGLL：执行非法指令，通常由于可执行文件本身出现了问题，或者试图执行数据段，堆栈溢出的时候也有可能产生这个信号
5. SIGTRAP： 由断点指令或者其他的trap产生，由debugger使用
6. SIGSEGV：试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.
7. SIGUSR2:留给用户使用
8. SIGPIPE:管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。
9. SIGALRM:时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号
10. SIGTERM:程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。
11. SIGCHLD:子进程结束时, 父进程会收到这个信号。 如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程 来接管)。
12. SIGCONT:让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符
13. SIGSTOP:停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.
14. SIGTSTP:停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号
15. SIGTTIN:当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.
16. SIGTTOU:类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.
17. SIGURG:有”紧急”数据或out-of-band数据到达socket时产生.
18. SIGXCPU:超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。
19. SIGXFSZ:当进程企图扩大文件以至于超过文件大小资源限制。
20. SIGVTALRM:虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.
21. SIGPROF:类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.
22. SIGWINCH:窗口大小改变时发出.
23. SIGIO:文件描述符准备就绪, 可以开始进行输入/输出操作.
24. SIGPWR:Power failure
25. SIGSYS:非法的系统调用。